#!/usr/bin/env node
const fs = require("fs")
const path = require("path")
const promisify = require("util").promisify
const child_process = require("child_process")
const S3 = require("@aws-sdk/client-s3")
const minimist = require("minimist")
const tmp = require("tmp-promise")
const glob = require("glob")

async function main() {
  const args = await parseArgs(process.argv.slice(2))
  const s3 = new S3.S3Client({region: 'us-east-1'})

  // pull tree, build dirindex, push tree
  await runSync(`s3://${args.bucket}/${args.prefix}${args.tree}`, args.build)

  await buildDirectory(args.build, args, s3)

  console.log(`https://s3.amazonaws.com/${args.bucket}/${args.prefix}index.html`)
}

async function buildDirectory(dir, args, s3) {
  const reldir = path.relative(args.build, dir)
  console.log(`building ${path.join(reldir, 'index.json')}...`)
  const entries = await fs.promises.readdir(dir, {withFileTypes: true})
  if (dir === args.build && !entries.length) {
    throw new Error("empty dirindex")
  }
  const dirs = entries.filter(f => f.isDirectory()).map(f => f.name)
  const files = entries.filter(f => !f.isDirectory()).map(f => f.name)
    // ignore files generated by this script
    .filter(f => f !== "index.json" && f !== "index.html")
  const names = [...dirs.map(d => d + '/'), ...files]

  // windows path separator might be '\' or '/', but s3 must be '/'
  const keyPrefix = `${path.join(args.prefix, args.tree, reldir).replace(/\\/g, '/')}/`
  console.log(`pushing ${keyPrefix}index.json - ${names.length} files...`)
  if (!args.dryrun) {
    await s3.send(new S3.PutObjectCommand({
      Bucket: args.bucket,
      Key: `${keyPrefix}index.json`,
      ContentType: "application/json",
      Body: JSON.stringify(names),
    }))
  }

  console.log(`building ${path.join(reldir, 'index.html')}...`)
  const indexHtml = (await fs.promises.readFile(path.join(__dirname, 's3dirindex-template.html')))
    .toString()
    .replace(/\{\{\$LIST\}\}/g, names
      .map(f => `    <li><a href="${f}">${f}</a></li>`)
      .join("\n")
    )
  console.log(`pushing ${keyPrefix}index.html...`)
  if (!args.dryrun) {
    await s3.send(new S3.PutObjectCommand({
      Bucket: args.bucket,
      Key: `${keyPrefix}index.html`,
      ContentType: "text/html",
      Body: indexHtml,
    }))
  }

  for (let d of dirs) {
    await buildDirectory(path.join(dir, d), args, s3)
  }
}

async function runSync(src, dest, args=[]) {
  return new Promise((resolve, reject) => {
    console.log(`sync: ${src} --> ${dest}`)
    const p = child_process.spawn("aws", ["s3", "sync", src, dest].concat(args))
    // p.stdout.on('data', data => console.log(`${data}`))
    p.stdout.on('data', data => null)
    p.stderr.on('data', data => console.error(`${data}`))
    p.on('close', code => {
      if (code) {
        return reject(`aws s3 sync failure: ${code}`)
      }
      return resolve()
    })
  })
}

async function parseArgs(argv) {
  const args = minimist(argv)
  if (!args.bucket || !args.prefix) {
    console.error(`usage: node s3dirindex.js --bucket BUCKET --prefix PREFIX [--tree TREE_PREFIX] [--build BUILD_DIR]`)
    process.exit(1)
  }
  const {bucket, dryrun} = args
  const prefix = args.prefix || '/'
  if (prefix && !prefix.endsWith('/')) throw new Error('--prefix must end with "/"')
  const build = await getBuildDir(args)
  const tree = args.tree || ''
  return {prefix, bucket, tree, build, dryrun}
}

async function getBuildDir(args) {
  if (args.build) {
    await fs.promises.rmdir(args.build, {recursive: true})
    await fs.promises.mkdir(args.build, {recursive: true})
    return args.build
  }
  else {
    const d = await tmp.dir({unsafeCleanup: true})
    return d.path
  }
}

main().catch(err => {
  console.error(err)
  process.exit(1)
})
